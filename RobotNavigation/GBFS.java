package RobotNavigation;

/**
 * GBFS class - implementation of greedy best first search extends informed search
 * 
 * @author Zoie Tad-y
 * @version 14/04/2022
 */

import java.util.ArrayList;
import java.util.PriorityQueue;

import Search.InformedSearch;
import Search.Problem;

public class GBFS extends
        InformedSearch<RobotNavigationState, RobotNavigationAction, RobotNavigationNode, PriorityQueue<RobotNavigationNode>> {

    /**
     * constructor for GBFS
     * Passes arguments to super class
     * 
     * @param problem  - problem to solve with GBFS
     * @param frontier - container for holding nodes to expand
     */
    public GBFS(Problem<RobotNavigationState, RobotNavigationAction> problem,
            PriorityQueue<RobotNavigationNode> frontier) {
        super(problem, frontier);
    }

    /**
     * expands a given node sets the evaluation function and sequence number
     * of the new node that follows the specification in the textbook
     * Artificial Intelligence Modern Approach ed.4
     * 
     * @param node - node to expand
     */
    @Override
    public ArrayList<RobotNavigationNode> expand(RobotNavigationNode node) {
        // initialise and declare holder variables and containers
        ArrayList<RobotNavigationNode> sl = new ArrayList<RobotNavigationNode>();
        RobotNavigationState sc;
        int distanceToGoal;
        RobotNavigationNode newNode;

        // s<-node.STATE
        RobotNavigationState s = node.getState();
        // for each action in problem.ACTIONS(s) do
        for (RobotNavigationAction action : this.problem.actions(s)) {
            // s' <- problem.RESULT(s, action)
            sc = this.problem.result(s, action);
            // cost<-node.PATH-COST + problem.ACTION-COST(s, action,s')
            distanceToGoal = getDistanceToClosestGoal(sc);

            if (!reached.containsKey(sc) || distanceToGoal < reached.get(sc).getG()) {
                // set eval function
                // yield NODE(STATE=s', PARENT=node, ACTION=action, PATH-COST=distance to
                // closest end goal)
                // create a new node containing the state created
                newNode = new RobotNavigationNode(sc, action, node);
                newNode.setEvaluationFunction(0, distanceToGoal);
                // set sequence number
                newNode.setSequenceNumber(this.getNumberOfNodes());
                sl.add(newNode);
                // increment node counter
                this.incrementNumberOfNodes();
            }

        }
        // return list of new nodes
        return sl;
    }

    /**
     * perform greedy best first search
     */
    public RobotNavigationNode performSearch() {
        // node<-NODE(problem.INITIAL)
        RobotNavigationNode node = new RobotNavigationNode(problem.getInitial(),
                getDistanceToClosestGoal(problem.getInitial()));
        // node.sequenceNumber <- number of nodes in the counter
        node.setSequenceNumber(this.getNumberOfNodes());
        // node.f = g + f
        node.setEvaluationFunction(0, getDistanceToClosestGoal(problem.getInitial()));
        // increment node counter
        this.incrementNumberOfNodes();
        // frontier<-node
        this.frontier.add(node);
        // reached<-{problem.INITIAL}
        reached.put(problem.getInitial(), node);
        // declare holder variable for child states
        RobotNavigationState s;
        // while not IS-EMPTY(frontier) do
        while (!frontier.isEmpty()) {
            // node<-POP(frontier)
            node = frontier.poll();
            // if problem.IS-GOAL(node.STATE) then return node
            if (this.problem.isGoal(node.getState())) {
                return node;
            }
            // for each child in EXPAND(problem, node) do
            for (RobotNavigationNode child : this.expand(node)) {
                // s<- child.STATE
                s = child.getState();
                // if s is not in reached or child.PATH-COST < reached[s].PATH-COST then
                if (!reached.containsKey(s) || child.getG() < reached.get(s).getG()) {
                    // reached[s]<-child
                    reached.put(s, child);
                    // add child to frontier
                    this.frontier.add(child);
                }
            }
        }
        // return failure
        return null;
    }

    /**
     * display solution generated by GBFS in the format specified in the project
     * brief
     */
    @Override
    public void displaySolution(RobotNavigationNode node, String filename) {
        this.displaySolution(node, filename, "GBFS", this.getNumberOfNodes());
    }

}
