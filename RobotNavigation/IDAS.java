package RobotNavigation;

/**
 * IDAS class - implementation of Iterative Deepening A star search extends 
 * informed search
 * 
 * @author Zoie Tad-y
 * @version 14/04/2022
 */

import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;

import Search.InformedSearch;
import Search.Problem;

public class IDAS
        extends
        InformedSearch<RobotNavigationState, RobotNavigationAction, RobotNavigationNode, PriorityQueue<RobotNavigationNode>> {

    /**
     * constructor for IDAS
     * Passes arguments to super class
     * 
     * @param problem  - problem to solve with IDAS
     * @param frontier - container for holding nodes to expand
     */
    public IDAS(Problem<RobotNavigationState, RobotNavigationAction> problem,
            PriorityQueue<RobotNavigationNode> frontier) {
        super(problem, frontier);
        // TODO Auto-generated constructor stub
    }

    /**
     * expands a given node sets the evaluation function and sequence number of the
     * new node
     * 
     * @param node - node to expand
     */
    @Override
    public ArrayList<RobotNavigationNode> expand(RobotNavigationNode node) {
        // initialise and declare holder variables and containers
        ArrayList<RobotNavigationNode> sl = new ArrayList<RobotNavigationNode>();
        RobotNavigationState sc;
        RobotNavigationNode child;

        // s<-node.STATE
        RobotNavigationState s = node.getState();
        // for each action in problem.ACTIONS(s) do
        for (RobotNavigationAction action : this.problem.actions(s)) {
            // s' <- problem.RESULT(s, action)
            sc = this.problem.result(s, action);
            // if s is not in reached or child.PATH-COST < reached[s].PATH-COST then
            if (!reached.containsKey(sc) || node.getG() + 1 + getDistanceToClosestGoal(sc) < reached.get(sc).getF()) {
                // yield NODE(STATE=s', PARENT=node, ACTION=action, PATH-COST=cost)
                child = new RobotNavigationNode(sc, action, node);
                // node.f = g + f
                child.setEvaluationFunction(node.getG() + 1, getDistanceToClosestGoal(sc));
                // reached[s]<-child
                reached.put(sc, child);
                // add child to frontier
                sl.add(child);
                // set sequence number
                child.setSequenceNumber(this.getNumberOfNodes());
                // increment nodes created that are maintained
                this.incrementNumberOfNodes();
            }
        }
        // sort by f
        Collections.sort(sl);
        // return sl
        return sl;
    }

    /**
     * perform Iterative deepening A star search
     * A star that cuts off a search path based on a evaluation function value f
     * limit flimit
     * author references the Iterative Deepening search and depth limited search in
     * the
     * textbook Artificial Intelligence a Modern Approach ed.4, and modified it to
     * fit A star with cutoff
     * via eval function
     */
    @Override
    public RobotNavigationNode performSearch() {
        // node<-NODE(problem.INITIAL)
        RobotNavigationNode node = new RobotNavigationNode(problem.getInitial());
        // node.f = g + f
        node.setEvaluationFunction(0, getDistanceToClosestGoal(problem.getInitial()));
        // node.sequenceNumber <- number of nodes in the counter
        node.setSequenceNumber(this.getNumberOfNodes());
        // increment node counter
        this.incrementNumberOfNodes();

        // fLimit = inf
        int fLimit = Integer.MAX_VALUE;

        // holder variable for intermediate solution
        DFSCResult sol;

        // while true do
        while (true) {
            // sol, flimit <- DFS-CONTOUR(node, flimit)
            sol = DFSC(new DFSCResult(node, fLimit));
            // if sol is not null then return solution
            if (sol.getNode() != null) {
                return sol.node;
            }
            // if sol flimit is inf then return failure
            if (sol.getFLimit() == Integer.MAX_VALUE) {
                return sol.node;
            }
        }
    }

    /**
     * display solution generated by IDAS in the format specified in the project
     * brief
     */
    @Override
    public void displaySolution(RobotNavigationNode node, String filename) {
        this.displaySolution(node, filename, "CUS2 (IDAS)", this.getNumberOfNodes());

    }

    // helper field for DFS contour
    private int nextF = Integer.MAX_VALUE;

    /**
     * Depth first search contour
     * cuts off a star search based on a an evaluation function limit flimit
     * references Artificial Intelligence a Modern Approach ed.4 implementation of
     * Depth limited search
     * 
     * cycle checks are moved to function expand()
     * 
     * @param dfscr - helper result object for DFSC
     * @return - returns a goal node with the last flimit or null with a new flimit
     */
    private DFSCResult DFSC(DFSCResult dfscr) {
        // declare and intialise solution variable
        DFSCResult soldfscr = null;
        // if node.f > flimit then return null, node.f
        if (dfscr.getNode().getF() > dfscr.getFLimit()) {
            return new DFSCResult(null, dfscr.getNode().getF());
        }
        // if problem.IS-GOAL(node.STATE) then return node, flimit
        if (problem.isGoal(dfscr.getNode().getState())) {
            return new DFSCResult(dfscr.getNode(), dfscr.getFLimit());
        }
        // for each child in EXPAND(problem, node) do
        for (RobotNavigationNode node : expand(dfscr.getNode())) {
            // solution, new flimit = DFSC(node, flimit)
            soldfscr = DFSC(new DFSCResult(node, dfscr.getFLimit()));
            // if solution is non null then return solution, flimit
            if (soldfscr.getNode() != null) {
                return soldfscr;
            }
            // next-f limit <- min(nextf, newf)
            nextF = Math.min(dfscr.getFLimit(), soldfscr.getFLimit());
        }
        // return null, next f
        return new DFSCResult(null, nextF);
    }

    /**
     * helper class that will containg contouring results i.e. node, f limit
     */
    private static class DFSCResult {
        // node that the contour results with
        private RobotNavigationNode node;
        // limit that the contour results in
        private int FLimit;

        /**
         * constructor for contouring result object
         * 
         * @param node
         * @param FLimit
         */
        public DFSCResult(RobotNavigationNode node, int FLimit) {
            this.node = node;
            this.FLimit = FLimit;
        }

        /**
         * getter for node
         * 
         * @return - node result of contour
         */
        public RobotNavigationNode getNode() {
            return node;
        }

        /**
         * getter for flimit
         * 
         * @return
         */
        public int getFLimit() {
            return FLimit;
        }

    }

}
